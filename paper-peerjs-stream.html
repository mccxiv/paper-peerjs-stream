<!--suppress HtmlUnknownTarget -->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">

<script src="../peerjs/peer.js"></script> <!-- TODO: use min, use import maybe? -->

<polymer-element name="paper-peerjs-stream">

	<template>
		<style>
			:host {
				min-height: 100px;
				display: block;
				position: relative;
				background-color: black;
			}

			video {
				height: 100%;
				display: block;
				margin: 0 auto;
			}

			paper-spinner {
				width: 86px;
				height: 86px;
				position: absolute;
				top: calc(50% - 43px);
				left: calc(50% - 43px);
			}

			paper-spinner::shadow .circle {
				border-width: 8px;
			}
		</style>

		<div class="main">
			<video src="{{_remoteStreamURL}}" on-playing="{{_handlePlaying}}" autoplay muted></video>

			<template if="{{!haveRemoteStream}}">
				<paper-spinner active></paper-spinner>
			</template>
		</div>
	</template>

	<script>

		'use strict';

		//noinspection JSValidateTypes, JSUnusedGlobalSymbols, JSValidateJSDoc

		Polymer({
			publish: {

				/**
				 * Using the official cloud server?
				 * Provide your PeerJS API key.
				 *
				 * @attribute key
				 * @type string
				 */
				key: null,

				/**
				 * Hosting your own server? https://github.com/peers/peerjs-server
				 * These properties will be used if no key was provided
				 *
				 * PeerJS server host (omit http://)
				 * @attribute host
				 * @type string
				 * @default 'localhost'
				 *
				 * PeerJS server port
				 * @attribute port
				 * @type number
				 * @default 80
				 *
				 * Path on the server
				 * @attribute path
				 * @type string
				 * @default '/'
				 */
				host: 'localhost',
				port: 80,
				path: '/',

				/**
				 * This peer's ID.
				 * Optional, the server can provide one
				 *
				 * @attribute self
				 * @type string
				 */
				self: {value: null, reflect: true},

				/**
				 * The id of a remote broadcaster.
				 *
				 * Behavior:
				 * - Sends call-requests (not calls) to the broadcaster.
				 * - Answers calls from that broadcaster only.
				 *
				 * Explanation:
				 * - Generally, a spectator wants to consume a particular
				 *   broadcaster's stream, acting as a client.
				 *
				 * @attribute spectate
				 * @type string
				 */
				spectates: {value: null, reflect: true},

				/**
				 * If true and if a local stream was provided,
				 * answers any incoming call requests by calling.
				 *
				 * Behavior:
				 * - Responds to call-requests (not calls) by calling back.
				 *
				 * Explanation:
				 * - Generally, a broadcaster will sit around waiting for
				 *   a spectator to send a call request, acting as a server
				 *
				 * @attribute broadcast
				 * @type boolean
				 * @default false
				 */
				broadcasts: {value: false, reflect: true},

				/**
				 * If present, and if a local stream is available, calls the peer
				 *
				 * Behavior
				 * - Calls peer
				 *
				 * @attribute calls
				 * @type string
				 */
				calls: null,

				/**
				 * If true, answers calls
				 *
				 * behavior:
				 * - Answers any call
				 *
				 * @attribute answers
				 * @type boolean
				 * @default false
				 */
				answers: {value: false, reflect: true}
			},

			computed: {
				inCall: '!!_call',
				isAttached: '!!parentNode',
				peerActive: 'peer && !peer.destroyed && !peer.disconnected',
				peerDestroyed: 'peer && peer.destroyed',
				peerDisconnected: 'peer && peer.disconnected',
				haveLocalStream: '_localStream && !_localStream.ended',
				haveRemoteStream: '_remoteStream && !_remoteStream.ended'
			},

			peer : undefined,             // PeerJS instance, will change throughout lifecycle
			_call: undefined,             // The current call
			_timeout: 3000,               // Wait this long between attempts
			_attached : false,            //
			_localStream: undefined,      // Stream that will be sent
			_remoteStream: undefined,     // Stream received from call
			_remoteStreamURL: undefined,  // Stream in url form, for src
			_queuedMain: 0,               // To prevent multiple operations

			/**
			 * Provide a stream for use in calls.
			 * Some actions won't work until a stream is provided with this method.
			 *
			 * @public
			 * @param {MediaStream} stream
			 */
			setStream: function(stream) {
				this._localStream = stream;
				this._main();
			},

			attached: function() {
				console.info('ready');
				this._main();
			},

			detached: function() {
				console.info('detached');
				if (this.peer) this.peer.destroy();
			},

			domReady: function() {
				console.info('domReady');
			},

			/**
			 * Main program logic.
			 * Should run once an operation finishes and on certain events
			 */
			_main: function() {

				if (!this.isAttached) {
					// Should not be active unless attached to the DOM
					console.info('Not attached to the DOM, aborting operations');
					if (this.peer) {
						console.info('Destroying peer');
						this.peer.destroy();
					}
					return;
				}

				console.log('Checking what needs to be done');
				if (this.spectates || this.broadcasts || this.calls || this.answers) {
					if (!this.inCall) {
						if (!this.peerActive) {
							console.info('Not in a call and peer not ready, preparing peer');
							if (this.peerDisconnected && !this.peerDestroyed) this.peer.reconnect();
							else this._createPeer();
						}
						else if (this.calls) {
							console.info('Not in a call and need to call someone, calling...');
							this._performCall(this.calls);
						}
						else if (this.spectates) {
							console.info('Not in a call and should be spectating, requesting call');
							this._requestCall();
						}
						else console.info('Waiting for connections...')
					}
					else if (this.peer) {
						if (!this.peerDisconnected) {
							// Crucial step. PeerJS will close all media connections
							// if the peer's connection to the server dies.
							// This default behavior is undesirable, there should be
							// no need to end streams even if the server hiccups.
							console.info('Already in a call, disconnecting peer as its not needed');
							this.peer.disconnect();
						}
						else console.info('Peer not needed and was already disconnected');
					}
					else console.warn('This should not happen, in a call but have no peer reference');
				}
				else console.info('No work needed, no tasks declared.')
			},

			_mainDelayed: function() {
				if (this._queuedMain) return;
				this._queuedMain = setTimeout(function () {
					this._queuedMain = null;
					this._main();
				}.bind(this), this._timeout);
			},

			_createPeer: function() {
				var peerOpts = {debug: 3};
				if (this.key) peerOpts.key = this.key;
				else {
					peerOpts.host = this.host;
					peerOpts.port = this.port;
					peerOpts.path = this.path;
				}
				this.peer = this.self ? new Peer(this.self, peerOpts) : new Peer(peerOpts);
				this.peer.on('open', this._handlePeerOpen.bind(this));
				this.peer.on('error', this._handlePeerError.bind(this));
				this.peer.on('call', this._handleCall.bind(this));
				this.peer.on('connection', this._handleConnection.bind(this));
			},

			_handlePeerOpen: function(id) {
				this.self = id;
				this.fire('id', id);
				this._main();
			},

			_handlePeerError: function(error) {
				if (error.type === 'peer-unavailable') {
					// Non fatal error, give back control.
					this._mainDelayed();
				}
				else {
					// Assume fatal error, make sure it's dead and go back.
					this.peer.destroy();
					this._mainDelayed();
				}
			},

			_handleConnection: function(conn) {
				if (this.broadcasts) {
					if (conn.metadata === 'call-request') {
						this._handleCallRequest(conn.peer);
					}
				}
			},

			_performCall: function(remote) {
				if (this.haveLocalStream) {
					this._call = this.peer.call(remote, this._localStream);
					this._call.on('close', this._handleCallEnd.bind(this));
					this._call.on('error', this._handleCallEnd.bind(this));

					// this._main(); TODO: why doesn't this work?
					this._mainDelayed();
				}
				else {
					console.warn('Want to call, but no stream is available');
					this._mainDelayed();
				}
			},

			_handleCallRequest: function(remote) {
				if (!this.inCall) this._performCall(remote);
				else console.warn('Already in a call, ignoring call-request');
			},

			_requestCall: function() {
				var pps = this;
				var successful = false;
				var conn = this.peer.connect(this.spectates, {
					reliable: true,
					metadata: 'call-request'
				});
				conn.on('open', function () {
					successful = true;
					console.info('Closing unnecessary data connection');
					conn.close(); // Not needed anymore, request was sent.

					// Now it's up to the broadcaster to call us back.
					// Try again in a bit in case no call was received.
					pps._mainDelayed()
				});
				conn.on('close', requestFailure);
				conn.on('error', requestFailure);
				function requestFailure() {
					if (!successful) {
						console.warn('Call request failed');
						pps._mainDelayed();
					}
				}
			},

			_handleCall: function(call) {
				if (this.inCall) return; // One at a time please.
				if (call.peer !== this.spectates && !this.answers) return;

				this._call = call;
				this.haveLocalStream ? call.answer(this._localStream) : call.answer();
				this._call.on('stream', this._handleStream.bind(this));
				this._call.on('close', this._handleCallEnd.bind(this));
				this._call.on('error', this._handleCallEnd.bind(this));

				//this._main(); // breaks!
				this._mainDelayed(); // TODO: why does this work but not previous?
			},

			_handleCallEnd: function(e) {
				console.warn('call ended, closing just to make sure', e);
				this._call.close(); // Making sure it's destroyed.
				this._call = null;
				this._mainDelayed();
			},

			_handleStream: function(stream) {
				this._remoteStream = stream;
				this._remoteStreamURL = URL.createObjectURL(stream);
				stream.addEventListener('ended', this._handleStreamEnded.bind(this));
				this._mainDelayed(); // TODO: is this unnecessary?
			},

			_handleStreamEnded: function()
			{
				// TODO: ??
				// Consider a different approach. Can a stream come back
				// using the same call?
				console.warn('stream ended, reconnecting...');

				if (this._call) {
					if (this._call.open) console.warn('Stream ended but call is active, closing call anyways');
					this._call.close(); // Just to be safe
					this._call = null;
				}
				this._mainDelayed();
			},

			_handlePlaying: function(e, detail, sender) {
				//noinspection JSUnresolvedFunction
				sender.animate([
						{opacity: 0, transform: 'scale3d(.3, .3, .3)'},
					 	{opacity: 1, transform: 'none'}],
					{duration: 500, easing: 'cubic-bezier(.55, 0, .1, 1)'}
				);
			}
		});
	</script>

</polymer-element>