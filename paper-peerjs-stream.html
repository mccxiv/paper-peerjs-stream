<!--suppress ALL -->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-slider/paper-slider.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">

<script src="../peerjs/peer.min.js"></script>
<script src="../screenfull/dist/screenfull.js"></script>

<polymer-element name="paper-peerjs-stream">
	<template>
		<link rel="stylesheet" href="styles.css">
			<video id="video" src="{{_remoteStreamURL}}" on-playing="{{_handlePlaying}}" autoplay></video>
			<paper-spinner id="spinner" active></paper-spinner>
			<div id="toolbar">
				<paper-slider id="volume" value="[[volume]]" on-immediate-value-change="{{_volumeSliderChange}}" min="0" max="1" step="0.01"></paper-slider>
				<paper-button id="fullscreen" on-click="{{_toggleFullscreen}}">
					<core-icon icon="settings-overscan"></core-icon>
				</paper-button>
			</div>
	</template>

	<script>

		'use strict';

		//noinspection JSValidateTypes, JSUnusedGlobalSymbols, JSValidateJSDoc
		Polymer({
			publish: {
				/**
				 * Using the official cloud server?
				 * Provide your PeerJS API key.
				 *
				 * @attribute key
				 * @type string
				 */
				key: null,

				/**
				 * Hosting your own server? https://github.com/peers/peerjs-server
				 * These properties will be used if no key was provided
				 *
				 * PeerJS server host (omit http://)
				 * @attribute host
				 * @type string
				 * @default 'localhost'
				 *
				 * PeerJS server port
				 * @attribute port
				 * @type number
				 * @default 80
				 *
				 * Path on the server
				 * @attribute path
				 * @type string
				 * @default '/'
				 */
				host: 'localhost',
				port: 80,
				path: '/',

				/**
				 * This peer's ID.
				 * Optional, the server can provide one
				 *
				 * @attribute self
				 * @type string
				 */
				self: {value: null, reflect: true},

				/**
				 * The id of a remote broadcaster.
				 *
				 * Behavior:
				 * - Sends call-requests (not calls) to the broadcaster.
				 * - Answers calls from the broadcaster only.
				 *
				 * Explanation:
				 * - Generally, a spectator wants to consume a particular
				 *   broadcaster's stream, acting as a client.
				 *
				 * @attribute spectate
				 * @type string
				 */
				spectates: {value: null, reflect: true},

				/**
				 * If true and if a local stream was provided,
				 * answers any incoming call requests by calling.
				 *
				 * Behavior:
				 * - Responds to call-requests (not calls) by calling back.
				 *
				 * Explanation:
				 * - Generally, a broadcaster will sit around waiting for
				 *   a spectator to send a call request, acting as a server
				 *
				 * @attribute broadcast
				 * @type boolean
				 * @default false
				 */
				broadcasts: {value: false, reflect: true},

				/**
				 * If present, and if a local stream is available, calls the peer
				 *
				 * Behavior
				 * - Calls peer
				 *
				 * @attribute calls
				 * @type string
				 */
				calls: null,

				/**
				 * If true, answers calls
				 *
				 * behavior:
				 * - Answers any call
				 *
				 * @attribute answers
				 * @type boolean
				 * @default false
				 */
				answers: {value: false, reflect: true},

				/**
				 * If true, the element will not wait for .start()
				 * Also causes the element to start and stop when
				 * this attribute is dynamically changed
				 *
				 * @attribute active
				 * @type boolean
				 * @default false
				 */
				active: {value: false, reflect: true},

				/**
				 * Volume of the incoming stream, from 0 to 1
				 *
				 * @attribute volume
				 * @type number
				 * @default 0.75
				 */
				volume: {value: 0.75, reflect: true},

				/**
				 * Css color to use for UI elements like the volume control.
				 * May also be set via styles instead of using this attribute.
				 *
				 * @attribute uicolor
				 * @type string
				 * @default '#FF5722' - Deep Orange google.com/design/spec/style/color.html
				 */
				uicolor: '#FF5722'
			},

			computed: {
				_inCall: '!!_call',
				_isAttached: '!!parentNode',
				_peerActive: 'peer && !peer.destroyed && !peer.disconnected',
				_peerDestroyed: 'peer && peer.destroyed',
				_peerDisconnected: 'peer && peer.disconnected',
				_haveLocalStream: '_localStream && !_localStream.ended',
				_haveRemoteStream: '_remoteStream && !_remoteStream.ended'
			},

			peer : undefined,    // PeerJS instance, will change throughout lifecycle

			_call: undefined,             // The current call
			_timeout: 3000,               // Wait this long between attempts
			_callRequest: undefined,      // reference to the call request, necessary to clean up
			_localStream: undefined,      // Stream that will be sent
			_remoteStream: undefined,     // Stream received from call
			_remoteStreamURL: undefined,  // Stream in url form, for src
			_queuedMain: 0,               // To prevent multiple operations

			_easing: 'cubic-bezier(.55, 0, .1, 1)',  // Easing for use in animations

			/**
			 * Provide a stream for use in calls.
			 * Some actions won't work until a stream is provided with this method.
			 *
			 * @public
			 * @param {MediaStream} stream
			 */
			setStream: function(stream) {
				this._localStream = stream;
				this._main();
			},

			/**
			 * Lifecycle handlers
			 */
			ready: function() {this._main();},


			/**
			 * Observers?! SO COOL
			 */
			_haveRemoteStreamChanged: function(oldVal, newVal) {
				if (newVal) {
					this._uiHideSpinner();
					this.fire('remote-stream', this._remoteStream);
				}
				else {
					this._uiShowSpinner();
					this.fire('remote-stream-end')
				}
			},

			attributeChanged: function(attribute) {
				if (attribute !== 'volume')	this._main();
			},

			volumeChanged: function() {
				this.$.video.volume = this.volume;
				// update slider? No, it bugs out
			},

			selfChanged: function() {
				this.fire('new-id')
			},

			/**
			 * Main program logic.
			 * Should run when an operation finishes and on certain events
			 */
			_main: function() {

				if (!this.active) {
					console.info('PPS: Not active or not attached to DOM, aborting.');
					this._destroyCall();
					this._destroyPeer();
					return;
				}

				console.info('PPS: Checking what needs to be done.');
				if (this.spectates || this.broadcasts || this.calls || this.answers) {
					if (!this._inCall) {
						if (!this._peerActive) {
							console.info('PPS: Not in a call and peer not ready, preparing peer.');
							if (this._peerDisconnected && !this._peerDestroyed) this.peer.reconnect();
							else this._createPeer();
						}
						else if (this.calls) {
							console.info('PPS: Not in a call and need to call someone, calling...');
							this._performCall(this.calls);
						}
						else if (this.spectates) {
							console.info('PPS: Not in a call and should be spectating, requesting call.');
							this._requestCall();
						}
						else console.info('PPS: Waiting for connections...')
					}
					else if (this.peer) {
						if (!this._peerDisconnected) {
							// Crucial step. PeerJS will close all media connections
							// if the peer's connection to the server dies.
							// This default behavior is undesirable, there should be
							// no need to end streams even if the server hiccups.
							console.info('PPS: Already in a call, disconnecting from server as it\'s not needed.');
							this.peer.disconnect();
						}
						else {
							// Call exists, peer is disconnected.
							console.info('PPS: Peer not needed and was already disconnected.');
						}
					}
					else console.warn('PPS: This should not happen, in a call but have no peer reference.');
				}
				else console.info('PPS: No work needed, no tasks declared.')
			},

			_mainDelayed: function() {
				if (this._queuedMain) return;
				this._queuedMain = setTimeout(function () {
					this._queuedMain = null;
					this._main();
				}.bind(this), this._timeout);
			},

			_createPeer: function() {
				var peerOpts = {debug: 3};
				if (this.key) peerOpts.key = this.key;
				else {
					peerOpts.host = this.host;
					peerOpts.port = this.port;
					peerOpts.path = this.path;
				}
				this.peer = this.self ? new Peer(this.self, peerOpts) : new Peer(peerOpts);
				console.info('PPS: Peer created, waiting for open event');
				this.peer.on('open', this._handlePeerOpen.bind(this));
				this.peer.on('error', this._handlePeerError.bind(this));
				this.peer.on('call', this._handleCall.bind(this));
				this.peer.on('connection', this._handleConnection.bind(this));
			},

			_destroyPeer: function() {
				if (this.peer) {
					console.info('PPS: Destroying peer.');
					this.peer.destroy();
					this.peer.removeAllListeners();
				}
			},

			_destroyCall: function() {
				console.info('PPS: Closing any existing call.');
				this._cleanUpConnection(this._call);
				this._call = null;
			},

			_handlePeerOpen: function(id) {
				this.self = id;
				console.info('PPS: Connection to server open.');
				this.fire('server-connection');
				this._main();
			},

			_handlePeerError: function(error) {
				console.info('PPS: Peer error', error);
				if (error.type === 'peer-unavailable') {

					if (this._callRequest) {
						console.info('Cleaning up failed call request');
						console.log('INFO', this._callRequest.listeners().length);
						console.log(this._callRequest);
						this._callRequest.close();
						this._callRequest.removeAllListeners();
					}

					// Non fatal error, give back control.
					this._mainDelayed();
				}
				else {
					// Assume fatal error, make sure it's dead and go back.
					this._destroyPeer();
					this._mainDelayed();
				}
			},

			_handleConnection: function(conn) {
				if (this.broadcasts) {
					if (conn.metadata === 'call-request') {
						this._handleCallRequest(conn.peer);
					}
				}
			},

			_performCall: function(remote) {
				if (this._haveLocalStream) {
					this._call = this.peer.call(remote, this._localStream);
					this._call.on('close', this._handleCallEnd.bind(this));
					this._call.on('error', this._handleCallEnd.bind(this));

					// this._main(); TODO: why doesn't this work?
					this._mainDelayed();
				}
				else {
					console.warn('PPS: Want to call, but no stream is available.');
					this._mainDelayed();
				}
			},

			_handleCallRequest: function(remote) {
				if (!this._inCall) this._performCall(remote);
				else console.warn('PPS: Already in a call, ignoring call-request.');
			},

			_requestCall: function() {
				console.info('PPS: Requesting a call.')
				var pps = this;
				var successful = false;

				// Need to save a reference in order to clean up later.
				// Explanation: if the remote peer is unavailable it will
				// trigger a peer error but NO connection error (why?!)
				this._callRequest = this.peer.connect(this.spectates, {
					reliable: true,
					metadata: 'call-request'
				});

				var conn = this._callRequest;
				conn.on('open', function () {
					successful = true;
					console.info('PPS: Closing unnecessary data connection.');
					conn.close(); // Not needed anymore, request was sent.
					conn.removeAllListeners();

					// Now it's up to the broadcaster to call us back.
					// Try again in a bit in case no call was received.
					pps._mainDelayed()
				});
				conn.on('close', requestFailure);
				conn.on('error', requestFailure);
				function requestFailure() {
					console.warn('PPS: Call request ended.');
					conn.removeAllListeners();
					if (!successful) {
						console.warn('PPS: Call request failed.');
						pps._mainDelayed();
					}
				}
			},

			_handleCall: function(call) {
				if (this._inCall) return; // One at a time please.
				if (call.peer !== this.spectates && !this.answers) return;

				this._call = call;
				this._haveLocalStream ? call.answer(this._localStream) : call.answer();
				this._call.on('stream', this._handleStream.bind(this));
				this._call.on('close', this._handleCallEnd.bind(this));
				this._call.on('error', this._handleCallEnd.bind(this));

				//this._main(); // breaks!
				this._mainDelayed(); // TODO: why does this work but not previous?
			},

			_handleCallEnd: function(e) {
				console.warn('PPS: call ended, cleaning up its listeners.');
				this._destroyCall();
				this._mainDelayed();
			},

			_handleStream: function(stream) {
				this._remoteStream = stream;
				this._remoteStreamURL = URL.createObjectURL(stream);
				stream.addEventListener('ended', this._handleStreamEnded.bind(this)); // TODO does this leak?
				this._mainDelayed(); // TODO: is this unnecessary?
			},

			_handleStreamEnded: function()
			{
				// TODO: ??
				// Consider a different approach. Can a stream come back
				// using the same call?
				console.warn('PPS: stream ended, reconnecting...');

				this._destroyCall();
				this._uiHandleStreamEnd();
				this._mainDelayed();
			},

			_handlePlaying: function() {
				this._uiHandleStreamStart()
			},

			/* UI handlers */

			_uiHandleStreamStart: function() {
				this._uiHideSpinner();
				this._uiShowVideo();
			},

			_uiHandleStreamEnd: function() {
				this._uiShowSpinner();
			},

			_uiShowSpinner: function() {
				//noinspection JSUnresolvedVariable
				var spinner = this.$.spinner;
				var from =  {opacity: 0};
				var to =    {opacity: 1};
				var opts =  {duration: 5000, easing: this._easing};

				spinner.setAttribute('active', true);
				spinner.style.display = 'inline-block';

				//noinspection JSUnresolvedFunction
				spinner.animate([from, to], opts);
			},

			_uiHideSpinner: function() {
				//noinspection JSUnresolvedVariable
				var spinner = this.$.spinner;
				var from =  {opacity: 1};
				var to =    {opacity: 0};
				var opts =  {duration: 500, easing: this._easing};

				//noinspection JSUnresolvedFunction
				var anim = spinner.animate([from, to], opts);

				anim.addEventListener('finish', function() {
					spinner.removeAttribute('active');
					spinner.style.display = 'none';
				}.bind(this));
			},

			_uiShowVideo: function() {
				var from =  {opacity: 0, transform: 'scale3d(.3, .3, .3)'};
				var to =    {opacity: 1, transform: 'none'};
				var opts =  {duration: 500, easing: this._easing};

				//noinspection JSUnresolvedFunction, JSUnresolvedVariable
				this.$.video.animate([from, to], opts);
			},

			_toggleFullscreen: function() {
				if (screenfull.enabled) {
					screenfull.toggle(this);
					if (screenfull.isFullscreen) {
						this.style.display = 'block';
						this.style.width = '100%';
						this.style.height = '100%';
					}
					else {
						this.style.removeProperty('display');
						this.style.removeProperty('width');
						this.style.removeProperty('height');
					}
				}
			},

			_volumeSliderChange: function() {
				this.volume = this.$.volume.immediateValue;
			},

			_cleanUpConnection: function(conn) {
				if (conn && conn.close) {
					conn.close();
					conn.removeAllListeners();
				}
			}
		});
	</script>

</polymer-element>